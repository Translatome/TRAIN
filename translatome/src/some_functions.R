#!/bin/env Rscript
#'=============================================================================
#'                    R functions for RNA-seq analysis
#'=============================================================================


#' Import file as a dataframe
#'=============================================================================
#' Function_name: ImportFileAsDF
#' --------------
#'
#' Description:
#' ------------
#' This function imports a count file and converts it to a data.frame object
#' using the fread() function from the data.table library.
#' It also renames the columns based on the provided count type.
#'
#' Usage:
#' ------
#'  ```R
#'  ImportFileAsDF(dataframe, count_tool)
#' ```
#'
#' Arguments:
#' ----------
#' - `dataframe`:
#'   The name of the file containing the count data.
#' - `count_tool`:
#'   The type of count used. Two options are available:
#'    * `"featurecounts"`:  for count generated by FeatureCounts.
#'    * `"htseq"`: for count generated by HTSeq.
#'    * `""`: only if columns have the same names as samples names
#'
#' Value:
#' ------
#' The function returns a data.frame object containing the imported and renamed
#' count data.
#'
#' Examples:
#' ---------
#' ```R
#'  # Import of a featurecounts table
#'  data <- ImportFileAsDF("data.txt", "featurecounts")
#'  head(data)
#'  # Import of a htseq-counts table
#'  data <- ImportFileAsDF("data.txt", "htseq")
#'  head(data)
#' ```
#'
#' See also
#' --------
#' [data.table::fread()](https://rdrr.io/github/Rdatatable/data.table/man/fread.html)
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll
#' - Created: 2023-04-12
#' - License: CeCILL
#' - Version: 0.1.0


ImportFileAsDF <- function(dataframe, count_tool) {
    ## Import count file
    data <- data.table::fread(
      dataframe,
      header = TRUE,
      data.table = FALSE
    )
    rownames(data) <- data$Geneid
    data <- data[, -1]
    print("Info text: Import of data")
    ## Rename columns
    if (count_tool == "featurecounts") {
        colnames(data) <- gsub("counts_", "", colnames(data))
        print(head(data))
    } else if (count_tool == "htseq") {
        colnames(data) <- gsub("_ReadCount_BasedOnGene", "", colnames(data))
        print(head(data))
    } else {
        print("Please note: your column names must be identical to 
              the names of the samples.")
        print(head(data))
    }
    return(data)
}


#' Functions for DESeq2 counts filtering
#'=============================================================================
#' Function_name: FilterMethods
#' --------------
#' 
#' Description:
#' ------------
#' This function filters low-count genes from a DESeq2 object based on the
#' provided metadata and filtering method.
#'
#' Usage:
#' ------
#'  ```R
#'  FilterMethods(deseq2_objt, metadata, filtering, verbose)
#' ```
#'
#' Arguments:
#' ----------
#' - `deseq2_objt`:
#'   A DESeq2 object containing count data.
#' - `metadata`:
#'   A data frame containing metadata information.
#'   Must include a column for replicates and a column for experimental design.
#' - `filtering`:
#'     The type of filtering method to use. Three options are available:
#'         `"edger"`: Filter by expression using edgeR package.
#'         `"deseq"`: Filter by count using DESeq2 package.
#'         `"none"`: No filtering.
#' - `verbose`:
#'     A boolean value indicating whether to print verbose output
#'     (i.e., filtering results) or not.
#'
#' Value:
#' ------
#' The function returns a DESeq2 object with low-count genes filtered out.
#'
#' Examples:
#' ---------
#'  ```R
#'  # Filter low-count genes using edgeR filtering method 
#'  # and print verbose output
#'  my_filtered_data <- FilterMethods(
#'    my_deseq2_objt,
#'    my_metadata,
#'    "edger",
#'    TRUE
#'  )
#'  head(counts(my_filtered_data))
#'  
#'  # Filter low-count genes using DESeq filtering method 
#'  # and do not print verbose output
#'  my_filtered_data <- FilterMethods(
#'    my_deseq2_objt,
#'    my_metadata,
#'    "deseq",
#'    FALSE
#'  )
#'  head(counts(my_filtered_data))
#'  ```
#'
#' See also
#' --------
#' - [DESeq2 package](http://bioconductor.org/packages/release/bioc/html/DESeq2.html)
#' - [edgeR package](http://bioconductor.org/packages/release/bioc/html/edgeR.html)
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll
#' - Created: 2023-04-12
#' - License: CeCILL
#' - Version: 0.1.0


FilterMethods <- function(deseq2_objt, metadata, filtering, verbose) {
    # Filtering method
    if (verbose == TRUE) {
        if (filtering == "edger") {
            mm <- model.matrix(~ 0 + metadata$combine)
            keep <- filterByExpr(
              deseq2_objt,
              design = mm,
              group = NULL
            )
            print("Filter low counts, keep counts > at 10 CPM, 
                  according to the matrix design")
            print(table(keep))
            dds2 <- deseq2_objt[keep, ]
        } else if (filtering == "deseq") {
            keep <- rowSums(counts(
                deseq2_objt, 
                normalized = TRUE
            ) >= 10) >= dim(table(metadata$replicate))
            print("Filter low counts, keep counts > at 10 CPM, 
                  according to the number of replicates")
            print(table(keep))
            dds2 <- deseq2_objt[keep, ]
        } else {
            keep <- rowSums(counts(
              deseq2_objt, 
              normalized = TRUE
            ) > 1) >= dim(table(metadata$replicate))
            print("Filter low counts, keep counts > at 1 CPM, 
                  according to the number of replicates")
            print(table(keep))
            dds2 <- deseq2_objt[keep, ]
        }
        print("Info text: Number of rows from data after filtering")
        print(dim(dds2))
    } else {
        if (filtering == "edger") {
            mm <- model.matrix(~ 0 + metadata$combine)
            keep <- filterByExpr(deseq2_objt, design = mm, group = NULL)
            dds2 <- deseq2_objt[keep, ]
        } else if (filtering == "deseq") {
            keep <- rowSums(counts(
              deseq2_objt, 
              normalized = TRUE
            ) >= 10) >= dim(table(metadata$replicate))
            dds2 <- deseq2_objt[keep, ]
        } else {
            keep <- rowSums(counts(
              deseq2_objt, 
              normalized = TRUE
            ) >= 1) >= dim(table(metadata$replicate))
            dds2 <- deseq2_objt[keep, ]
        }
    }
    return(dds2)
}


#' Function for Scree plot / Pareto line at 80 %
#'=============================================================================
#' Function_name: ScreeHist
#' --------------
#' 
#' Description:
#' ------------
#' The ScreeHist function generates a scree plot which displays the percentage
#' of variance explained by each principal component of a given dataset.
#'
#' Usage:
#' ------
#'  ```R
#'  ScreeHist(X, geom = c("bar", "line"), ncp = 10)
#' ```
#'
#' Arguments:
#' ----------
#' - `X`: a numeric matrix or data frame containing the principal component 
#'        scores.
#' - `geom`: a character vector that specifies the type of geometries to be 
#'           plotted. It can take "bar" and/or "line". Default value is "bar" 
#'           and "line".
#' - `ncp`: a positive integer specifying the maximum number of principal
#'          components to be displayed. Default value is 10.
#'
#' Details:
#' --------
#' The function extracts the top ncp principal components from the input X,
#' and generates a scree plot using ggplot2 package. The plot shows the
#' percentage of variance explained by each component, along with the
#' cumulative percentage of variance explained. It also includes a red
#' dashed line at 80% to indicate the suggested number of components to retain.
#'
#' Value:
#' ------
#' The function returns a ggplot object.
#'
#' Examples:
#' ---------
#'  ```R
#'  # Generate simulated data
#'  set.seed(123)
#'  X <- matrix(rnorm(400), nrow = 40, ncol = 10)
#'  pca <- prcomp(X)
#'  # Generate scree plot with both line and bar plot
#'  ScreeHist(X = pca$x, geom = c("bar", "line"), ncp = 10)
#'  ```
#'
#' See also
#' --------
#'     Wickham, H. ggplot2: Elegant Graphics for Data Analysis.
#'          Springer-Verlag New York, 2016.
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll
#' - Created: 2023-04-12
#' - License: CeCILL
#' - Version: 0.1.0


ScreeHist <- function(X, geom = c("bar", "line"), ncp = 10) {
    # reduce dimension to ncp value
    eig <- X[1:min(ncp, nrow(X)), , drop = FALSE]
    # prepare plot
    p <- ggplot(eig, mapping = aes(x = component_number, y = variance))
    if ("bar" %in% geom) {
        p <- p + geom_bar(
            stat = "identity", fill = "steelblue",
            color = "steelblue", width = 0.7
        )
    }
    if ("line" %in% geom) {
        p <- p + 
          geom_line(
            aes(y = cumulative_variance),
            color = "black",
            linetype = "solid"
          ) +
          geom_point(
            aes(y = cumulative_variance),
            shape = 19,
            color = "black"
          )
    }
    p <- p + 
      geom_line(
        y = 80,
        color = "red",
        linetype = "dashed"
      )
    p <- p + 
      geom_text(
        aes(label = round(variance, 1)),
        vjust = -0.4,
        hjust = 0.5
      )
    main <- "Scree plot"
    xlab <- "Dimensions"
    ylab <- "Percentage of explained variances"
    # plot labels and theme
    p <- p + 
      labs(
        title = main,
        x = xlab,
        y = ylab
      ) + 
      scale_x_continuous(breaks = 1:ncp)
    ggpubr::ggpar(p, ggtheme = theme_minimal())
}


#' Function for PCA computation with eigenvalue limits
#'=============================================================================
#' Function_name: ComputePCA2cond
#' --------------
#'
#' Description:
#' ------------
#' Compute PCA on a DESeq2 count matrix with 2 conditions.
#'
#' Usage:
#' ------
#'  ```R
#'  ComputePCA2cond(dataframe, metadata, design, factor1, factor2, filtering,
#'      model, respath)
#' ```
#'
#' Arguments:
#' ----------
#' - `dataframe`: A matrix of read counts, with rows as genes and columns 
#'                as samples.
#' - `metadata`: A data frame containing the experimental design of the samples.
#' - `design`: The experimental design formula.
#' - `factor1`: The name of the first factor for PCA grouping.
#' - `factor2`: The name of the second factor for PCA grouping.
#' - `filtering`: The name of the method for filtering samples.
#' - `model`: The type of model for fitting dispersion.
#' - `respath`: The path to the folder to store results.
#'
#' Details:
#' --------
#' This function creates a DESeqDataSet object, normalizes it and estimates 
#' dispersions.
#' Samples can be filtered using a specified method (see FilterMethods function).
#' Customized PCA transformation is performed based on the number of samples.
#' The PCA data, the PCA scree plot, and the cumulative variance are exported.
#' A histogram of the scree plot is also produced (see ScreeHist function).
#'
#' Value:
#' ------
#' A list containing the following components:
#' - `all_pca`: The PCA object containing all the principal components.
#' - `pcaDATA`: The PCA data, used for plotting.
#' - `eig_val`: A data frame containing the eigenvalues for each principal 
#'              component.
#'
#' Examples:
#' ---------
#'  ```R
#' data("iris")
#' iris_counts <- as.matrix(iris[, 1:4])
#' metadata <- iris[, 5]
#' metadata <- data.frame(Species = factor(metadata))
#' dds <- DESeqDataSetFromMatrix(countData = iris_counts,
#'                               colData = metadata,
#'                               design = ~ Species)
#' res <- ComputePCA2cond(dataframe = iris_counts,
#'                         metadata = metadata,
#'                         design = ~ Species,
#'                         factor1 = "Species",
#'                         factor2 = "",
#'                         filtering = "deseq",
#'                         model = "parametric",
#'                         respath = ".")
#'  ```
#'
#' See also
#' --------
#' [DESeq2 package](http://bioconductor.org/packages/release/bioc/html/DESeq2.html)
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll
#' - Created: 2023-04-12
#' - License: CeCILL
#' - Version: 0.1.0


ComputePCA2cond <- function(dataframe,
                            metadata,
                            design,
                            factor1,
                            factor2,
                            filtering,
                            model,
                            respath) {
    # Create Matrix according to different design
    dsqMat <- DESeqDataSetFromMatrix(
      countData = dataframe,
      colData = metadata,
      design = design
    )
    # Normalize and estimate dispersions
    dds <- dsqMat[rowSums(counts(dsqMat)) > 1, ]
    dds <- estimateSizeFactors(dds, type = "ratio")
    filt_dds <- FilterMethods(
      dds,
      metadata,
      filtering,
      verbose = FALSE
    )
    dds1 <- estimateDispersions(
      filt_dds,
      fitType = "parametric",
      quiet = TRUE
    )
    # Customized PCA transformation
    if (nrow(metadata) < 30) {
        print("number of samples is < at 30, we use the rlog 
              transformation for PCA")
        dsqLog <- rlogTransformation(dds1, fitType = model)
        dists <- dist(t(assay(dsqLog)))
        png(paste0(respath, "/Dendrogram.png"))
        plot(hclust(dists))
        dev.off()
        pcaData <- plotPCA(
          dsqLog,
          intgroup = c(factor2, factor1),
          returnData = TRUE
        )
    } else {
        print("number of samples is > at 30, we use the VST 
              transformation for PCA")
        print("why: http://master.bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html")
        dsqVST <- vst(dds1, fitType = model) # params: , blind = FALSE
        dists <- dist(t(assay(dsqVST)))
        png(paste0(respath, "/Dendrogram.png"))
        plot(hclust(dists))
        dev.off()
        pcaData <- plotPCA(
          dsqVST,
          intgroup = c(factor2, factor1),
          returnData = TRUE
        )
    }
    # Get PCA scree plot
    vsd <- varianceStabilizingTransformation(dds1, fitType = model)
    ## Calculate the variance for each gene
    rv <- rowVars(assay(vsd))
    ## Select the ntop genes by variance
    select <- order(rv, decreasing = TRUE)[seq_len(min(500, length(rv)))]
    ## Perform a PCA on the data in assay(x) for the selected genes
    pca <- prcomp(t(assay(vsd)[select, ]))
    ## The contribution to the total variance for each component
    percentVar <- (pca$sdev^2 / sum(pca$sdev^2)) * 100
    ## Plot the "percentVar"
    scree_plot <- data.frame(percentVar)
    scree_plot[, 2] <- c(1:length(percentVar))
    colnames(scree_plot) <- c("variance", "component_number")
    # Add cumulative variance
    scree_plot$cumulative_variance <- cumsum(scree_plot$variance)
    # End function
    return(list(all_pca = pca, pcaDATA = pcaData, eig_val = scree_plot))
}


#' Function for plotting PCA
#'=============================================================================
#' Function_name: PCAplots2cond
#' --------------
#'
#' Description:
#' ------------
#' This function generates a 2D plot of principal component analysis (PCA)
#' with color and shape-coded factors. The plot is saved in PNG and PDF format.
#'
#' Usage:
#' ------
#'  ```R
#'  PCAplots2cond(pcaData, eigvalue, factor1, factor2, respath)
#' ```
#'
#' Arguments:
#' ----------
#' - `pcaData`: a matrix or data frame containing the PCA data.
#' - `eigvalue`: a numeric vector of eigenvalues.
#' - `factor1`: a character vector of the factor used for color-coding.
#' - `factor2`: a character vector of the factor used for shape-coding.
#' - `respath`: a character string indicating the path to save the output plot
#'              files.
#'
#' Details:
#' --------
#' This function creates a 2D plot of principal component analysis (PCA)
#' based on the input data. The plot displays the first two principal components
#' with color and shape-coded factors. The plot is saved in both PNG and PDF
#' format for further use.
#'
#' Value:
#' ------
#' The function returns the plot generated as a ggplot2 object.
#'
#' Example:
#' --------
#'  ```R
#' library(ggplot2)
#' data(iris)
#' iris_pca <- prcomp(iris[, 1:4], center = TRUE, scale. = TRUE)
#' PCAplots2cond(iris_pca$x,
#'              iris_pca$sdev^2,
#'              factor1 = "Species",
#'              factor2 = "Species",
#'              respath = "./")
#'  ```
#'
#' See also
#' --------
#' [ggplot2 package](https://www.rdocumentation.org/packages/ggplot2/versions/3.4.2)
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll
#' - Created: 2023-04-12
#' - License: CeCILL
#' - Version: 0.1.0


PCAplots2cond <- function(pcaData, eigvalue, factor1, factor2, respath) {
    percentVar <- round(100 * attr(pcaData, "percentVar"))
    fig <- ggplot(
        pcaData,
        aes(
          PC1, 
          PC2, 
          color = pcaData[, factor1], 
          shape = pcaData[, factor2]
        )
    ) +
        labs(color = factor1, shape = factor2) +
        geom_point(size = 3) +
        xlab(paste0("PC1: ", percentVar[1], "% variance")) +
        ylab(paste0("PC2: ", percentVar[2], "% variance")) +
        theme_bw() +
        theme(panel.grid.minor = element_blank()) +
        theme(aspect.ratio = 1)
    plot(fig)
    png(paste0(respath, "/PCA_", factor1, "_", factor2, ".png"))
    plot(fig)
    dev.off()
    pdf(paste0(respath, "/PCA_", factor1, "_", factor2, ".pdf"))
    plot(fig)
    dev.off()
    return(fig)
}


#' Function for comparisons
#'=============================================================================
#' Function_name: ComparisonToTest
#' --------------
#'
#' Description:
#' ------------
#' This function performs differential analysis on the count data using
#' DESeq2 package in R. The function compares two groups (var1 and var2)
#' and identifies differentially expressed genes. The function generates
#' a histogram of p-values and exports the table of complete results with
#' a summary of filtered results based on the adjusted p-value and log
#' fold change.
#'
#' Usage:
#' ------
#'  ```R
#'  ComparisonToTest(cons, test, var1, var2, logF, adj_pval, respath)
#' ```
#'
#' Arguments:
#' ----------
#' - `cons`: DESeqDataSet object containing the count data.
#' - `test`: The condition that will be tested (as a character string).
#' - `var1`: First group to be compared (as a character string).
#' - `var2`: Second group to be compared (as a character string).
#' - `logF`: Absolute value of the log fold change threshold to filter
#'           the differentially expressed genes.
#' - `adj_pval`: Adjusted p-value threshold to filter the differentially
#'               expressed genes.
#' - `respath`: A character string specifying the path to store the results.
#'
#' Details:
#' --------
#' - This function uses the results function from DESeq2 package to
#'   perform differential analysis.
#' - A histogram of the p-values is generated and saved as a PNG file.
#' - The complete results table is saved as a TSV file.
#' - The function also prints the number of upregulated and downregulated
#'   genes and the total number of deregulated genes based on the adjusted
#'   p-value and log fold change threshold.
#'
#' Value:
#' ------
#' The function returns a data.frame with the complete results of differential
#' analysis.
#'
#' Example:
#' --------
#'  ```R
#' # load DESeq2 library and example dataset
#' library(DESeq2)
#' data("DESeqDataSetFromMatrix")
#' dds <- DESeqDataSetFromMatrix(countData = counts,
#'                              colData = colData,
#'                              design = ~ group)
#' # run ComparisonToTest function
#' ComparisonToTest(cons = dds,
#'                  test = "group",
#'                  var1 = "A",
#'                  var2 = "B",
#'                  logF = 2,
#'                  adj_pval = 0.05,
#'                  respath = "results/")
#'  ```
#'
#' See also
#' --------
#' [DESeq2 package](http://bioconductor.org/packages/release/bioc/html/DESeq2.html)
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll
#' - Created: 2023-04-12
#' - License: CeCILL
#' - Version: 0.1.0


ComparisonToTest <- function(cons, test, var1, var2, logF, adj_pval, respath) {
    # Contrast tested
    Res <- results(
      cons,
      contrast = c(test, var1, var2),
      alpha = adj_pval,
      pAdjustMethod = "BH"
    )
    # Draw an histogram of the p-value
    hist(
      Res$padj,
      breaks = 20, col = "grey",
      main = "DESeq2_separate p-value distribution",
      xlab = "DESeq2_separate P-value",
      ylab = "Number of genes"
    )
    # Save it
    png(paste(respath, "/pval_", var1, "_vs_", var2, ".png", sep = ""))
    hist(
      Res$padj,
      breaks = 20, col = "grey",
      main = "DESeq2_separate p-value distribution",
      xlab = "DESeq2_separate P-value",
      ylab = "Number of genes"
    )
    dev.off()
    # Change colnames before export
    Res$identifier <- rownames(Res)
    head(Res)
    # Export table of complete results
    write.table(
      Res,
      file = paste(respath, "/", var1, "_vs_", var2, ".tsv", sep = ""),
      quote = FALSE, 
      row.names = FALSE, 
      sep = "\t"
    )
    print(paste("Differential Analysis For", var1, "vs", var2, sep = " "))
    # Na omit
    res_woNA <- na.omit(Res)
    print("------------")
    # Filter on adjusted p-value
    filt_res <- res_woNA[res_woNA$padj <= as.numeric(adj_pval), ]
    # Filter on logFC value
    logup <- filt_res[filt_res$log2FoldChange >= as.numeric(logF), ]
    logdn <- filt_res[filt_res$log2FoldChange <= -as.numeric(logF), ]
    print(paste0("Up genes: ", nrow(logup)))
    print(paste0("Down genes: ", nrow(logdn)))
    print(paste0("Total deregulated genes: ", nrow(logup) + nrow(logdn)))
    print("------------")
    # End function
    return(Res)
}


#' Function for API of gprofiler
#'=============================================================================
#' Function_name: callAPI
#' --------------
#'
#' Description:
#' ------------
#' The callAPI function is used to perform Gene Ontology enrichment analysis
#' using the gost function from the gprofiler2 R package. The function takes
#' in input several parameters such as gene_list, background_list, organism_
#' name, pval_thr, correction, user_sources, and respath.
#'
#' Usage:
#' ------
#' ```R
#' callAPI(
#'   gene_list,
#'   background_list,
#'   organism_name,
#'   pval_thr,
#'   correction,
#'   user_sources,
#'   respath)
#' ```
#'
#' Arguments:
#' ----------
#' - `gene_list`: A character vector of gene symbols to be used as the query
#'          list for the enrichment analysis.
#' - `background_list`: A character vector of gene symbols to be used as the
#'          background list for the enrichment analysis.
#' - `organism_name`: A character string specifying the organism name for the
#'          enrichment analysis.
#' - `pval_thr`: A numeric value specifying the p-value threshold for the
#'          enrichment analysis.
#' - `correction`: A character string specifying the multiple testing correction
#'          method for the enrichment analysis.
#' - `user_sources`: A character vector specifying the data sources to be used
#'          for the enrichment analysis.
#' - `respath`: A character string specifying the path and filename for the
#'          output file.
#'
#' Details:
#' --------
#' The function uses the gost function to perform Gene Ontology enrichment
#' analysis on the input gene_list using the specified background_list as the
#' background. The organism_name parameter specifies the organism for the
#' enrichment analysis. The pval_thr parameter specifies the p-value threshold
#' for significance. The correction parameter specifies the multiple testing
#' correction method to be used. The user_sources parameter specifies the data
#' sources to be used for the enrichment analysis. The respath parameter
#' specifies the path and filename for the output file.
#'
#' Value:
#' ------
#' The function returns the gpro object returned by the gost function.
#' If the enrichment is null, the function will print a warning message and
#' return "WARNING: enrichment is null."
#'
#' Example:
#' --------
#'  ```R
#' gene_list <- c("BRCA1", "BRCA2", "TP53")
#' background_list <- c("ALB", "APOE", "EGFR", "ACTB", "GAPDH")
#' organism_name <- "hsapiens"
#' pval_thr <- 0.05
#' correction <- "bonferroni"
#' user_sources <- c("GO:BP", "WP", "CORUM")
#' respath <- "enrichment_results.tsv"
#'
#' enrichment <- callAPI(
#'   gene_list,
#'   background_list,
#'   organism_name,
#'   pval_thr,
#'   correction,
#'   user_sources,
#'   respath)
#'  ```
#'
#' See also
#' --------
#' [gost function](https://www.rdocumentation.org/packages/gprofiler2/versions/0.2.1/topics/gost)
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll
#' - Created: 2023-04-12
#' - License: CeCILL
#' - Version: 0.1.0

callAPI <- function(gene_list,
                    background_list,
                    organism_name,
                    pval_thr,
                    correction,
                    user_sources,
                    respath) {
  if (!is.null(
    gpro <- gost(
      gene_list,
      organism = organism_name,
      ordered_query = FALSE,
      multi_query = FALSE,
      significant = TRUE,
      exclude_iea = FALSE,
      measure_underrepresentation = FALSE,
      evcodes = TRUE,
      user_threshold = pval_thr,
      correction_method = correction,
      domain_scope = "custom",
      custom_bg = background_list,
      numeric_ns = "",
      sources = as.vector(user_sources),
      as_short_link = FALSE
    )
  )) {
    res_gpro <- as.matrix(gpro$result)
    res_gpro <- res_gpro[, c(
      "term_id", "source", "p_value", "term_size",
      "query_size", "intersection_size", "term_name",
      "precision", "recall", "effective_domain_size",
      "source_order", "parents", "evidence_codes",
      "intersection"
    )]
    write.table(res_gpro, respath, sep = "\t", row.names = FALSE)
  } else {
    print(paste0(
      "WARNING: enrichment is null for ", cat, " on ",
      as.vector(user_sources),
      sep = ""
    ))
    res_gpro <- "WARNING: enrichment is null."
    write.table(res_gpro, respath, sep = "\t", row.names = FALSE)
    gpro <- NULL
  }
  return(gpro)
}


# Specific theme for dotplot
#'=============================================================================
#' Credits:
#' --------
#' - Author:  Guangchuang YU Lab
#' - Git: https://github.com/YuLab-SMU
#'
#' Theme_dose and default_labeller functions provide from the work of
#' Guangchuang YU Lab.
#'
#' Origin packages: DOSE & enrichplot
#' due to incomptibilities with other packages in the R conda env
#' we choose to include only functionnalities required for the analysis.
#'
#' ggplot theme of DOSE
#'
#' @title theme_dose
#' @param font.size font size
#' @return ggplot theme
#' @importFrom ggplot2 theme_bw
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 element_text
#' @importFrom ggplot2 margin
#' @examples
#' library(ggplot2)
#' qplot(1:10) + theme_dose()
#' @export

theme_dose <- function(font.size = 14) {
    theme_bw() +
        theme(
            axis.text.x = element_text(
                colour = "black",
                size = font.size, vjust = 1
            ),
            axis.text.y = element_text(
                colour = "black",
                size = font.size, hjust = 1
            ),
            axis.title = element_text(
                margin = margin(10, 5, 0, 0),
                color = "black",
                size = font.size
            ),
            axis.title.y = element_text(angle = 90)
        )
}


#' default_labeller
#'
#' default labeling function that uses the
#' internal string wrapping function `yulab.utils::str_wrap`
default_labeller <- function(n) {
    function(str) {
        str <- gsub("_", " ", str)
        str_wrap(str, n)
    }
}


#' wraping long string to multiple lines
#'
#' @title str_wrap
#' @param string input string
#' @param width the maximum number of characters before wrapping to a new line
#' @return update strings with new line character inserted
#' @export
#' @author Guangchuang Yu and Erqiang Hu
str_wrap <- function(string, width = getOption("width")) {
    result <- vapply(string,
        FUN = function(st) {
            words <- list()
            i <- 1
            while (nchar(st) > width) {
                if (length(grep(" ", st)) == 0) break
                y  <- gregexpr(" ", st)[[1]]
                n  <- nchar(st)
                y  <- c(y, n)
                idx <- which(y < width)
                # When the length of first word > width
                if (length(idx) == 0) idx <- 1
                # Split the string into two pieces
                # The length of first piece is small than width
                words[[i]] <- substring(st, 1, y[idx[length(idx)]] - 1)
                st <- substring(st, y[idx[length(idx)]] + 1, n)
                i  <- i + 1
            }
            words[[i]] <- st
            paste0(unlist(words), collapse = "\n")
        },
        FUN.VALUE = character(1)
    )
    names(result) <- NULL
    result
}


#' Dotplot function
#'=============================================================================
#' Function_name: dotplot_classic
#' --------------
#'
#' Description:
#' ------------
#' Creates a dotplot using ggplot2 to display results from an enrichment
#' analysis. The function takes as input an enrichResult dataframe and
#' parameters to customize the plot.
#'
#' Usage:
#' ------
#' ```R
#' dotplot_classic(object,
#'                 x = "term_size",
#'                 color = "p.adjust",
#'                 showCategory,
#'                 size = NULL,
#'                 font.size,
#'                 title = "",
#'                 orderBy = "x",
#'                 decreasing = TRUE,
#'                 label_format)
#' ```
#'
#' Arguments:
#' ----------
#' - `object`: a dataframe containing enrichment results.
#' - `x`: A string specifying the column in the enrichResult object to use as
#'      the x-axis values. Defaults to "term_size".
#' - `color`: A string specifying the column in the enrichResult object to use
#'      as the color for the points. Can be one of "pvalue", "p.adjust", or
#'      "qvalue". Defaults to "p.adjust".
#' - `showCategory`: An integer specifying the number of categories to display
#'      in the plot.
#' - `size`: A string specifying the column in the enrichResult object to use
#'      for the size of the points. Defaults to NULL.
#' - `font.size`: An integer specifying the font size to use for the plot.
#'      Defaults to 12.
#' - `title`: A string specifying the title of the plot.
#'      Defaults to an empty string.
#' - `orderBy`: A string specifying the column in the enrichResult object to use
#'      for ordering the categories. If the parameter is set to an invalid
#'      column name, it defaults to "x".
#' - `decreasing`: A logical value indicating whether to order the categories
#'      in decreasing order. Defaults to TRUE.
#' - `label_format`: A string or function to customize the labels for the y-axis
#'      If a function is passed, it is applied to each label. If a string is
#'      passed, it is parsed with dplyr::interp() and then used to create a
#'      function to format the labels.
#'      Defaults to the default labeller function.
#'
#' Value:
#' ------
#' The function returns a ggplot object.
#'
#' Examples:
#' ---------
#' ```R
#' # Load the required package
#' library(ReactomePA)
#' # Create a sample enrichResult object
#' data(geneList)
#' data(geneListBackground)
#' res <- enrichPathway(gene         = geneList,
#'                      universe    = geneListBackground,
#'                      organism    = "hsa",
#'                      pvalueCutoff = 0.05)
#'
#' # Plot the top 5 categories by term size
#' dotplot_classic(res, showCategory = 5)
#'
#' # Plot the top 5 categories by p-value and use a custom label format
#' dotplot_classic(res, showCategory = 5, orderBy = "p.adjust",
#'                 label_format = function(label) {
#'                   paste0(substr(label, 1, 20), "...")
#'                 })
#' ```
#'
#' Note:
#' -----
#' This function requires the ggplot2 package to be installed.
#'
#' Credits:
#' --------
#' - Author: Guangchuang YU Lab
#' - Reimplemented by: Julie Ripoll
#' - Date: 2023-04-19
#' - License: CeCILL

dotplot_classic <- function(object,
                            x = "term_size",
                            color = "p.adjust",
                            showCategory,
                            size = NULL,
                            font.size = 12,
                            title = "",
                            orderBy = "x",
                            decreasing = TRUE,
                            label_format) {
    colorBy <- match.arg(color, c("pvalue", "p.adjust", "qvalue"))

    if (nrow(object) <= showCategory) {
        df <- object
        print("Number of terms is lower than required, adjust to term number")
    } else {
        df <- object[1:showCategory, ]
        print(paste0(
          "keep only ", 
          showCategory, 
          " best terms for plots based on adjusted p-value"
        ))
    }

    if (orderBy != "x" && !orderBy %in% colnames(df)) {
        message('wrong orderBy parameter; set to default `orderBy = "x"`')
        orderBy <- "x"
    }

    if (orderBy == "x") {
        df <- dplyr::mutate(df, x = eval(parse(text = x)))
    }

    label_func <- default_labeller(label_format)
    if (is.function(label_format)) {
        label_func <- label_format
    }

    idx <- order(df[[orderBy]], decreasing = decreasing)
    df$Description <- factor(
      df$Description,
      levels = rev(unique(df$Description[idx]))
    )
    ggplot(df, aes_string(
        x = x,
        y = "Description",
        size = size,
        color = colorBy
    )) +
        geom_point() +
        scale_color_continuous(
            low = "red", 
            high = "blue", 
            name = color,
            guide = guide_colorbar(reverse = TRUE)
        ) +
        scale_y_discrete(labels = label_func) +
        ylab(NULL) +
        ggtitle(title) +
        theme_dose(font.size) +
        scale_size(range = c(4, 8))
}


#' Function for gprahics on enrichment results
#'=============================================================================
#' Function_name: gproGraph
#' --------------
#'
#' Description:
#' ------------
#' `gproGraph` is a function that takes the output of the gost function (gpro)
#' and generates two plots: a bar plot and a dot plot. The bar plot shows the
#' top X number of enriched GO terms, while the dot plot shows the enriched GO
#' terms with their corresponding gene ratios.
#'
#' Usage:
#' ------
#' ```R
#' gproGraph(gpro_res, respath_plt1, respath_plt2, term_number)
#' ```
#'
#' Arguments:
#' ----------
#' - `gpro_res`: A result object generated by the gost function.
#' - `respath_plt1`: A character string specifying the file path to save
#'      the bar chart.
#' - `respath_plt2`: A character string specifying the file path to save
#'      the dot plot.
#' - `term_number`: An integer specifying the number of categories to display
#'      in the plot.
#'
#' Details:
#' --------
#' The gproGraph function first extracts the top X number of enriched GO terms
#' from the gpro_res output, and then generates a bar plot of these terms using
#' the gostplot function. The bar plot is saved to the file specified by
#' respath_plt1.
#' Next, the gpro_res output is modified to create a data frame suitable for
#' generating the dot plot using the dotplot_internal function. The modified
#' data frame includes the gene ratios for each enriched GO term, as well as 
#' the background gene ratios. The dot plot is saved to the file specified by
#' respath_plt2.
#'
#' Value:
#' ------
#' The gproGraph function does not return a value. It generates two plots and
#' saves them to the specified files.
#'
#' Example:
#' --------
#'  ```R
#' # Load example data
#' data(genes)
#'
#' # Perform GO enrichment analysis
#' gpro_res <- callAPI(gene_list = genes$gene_symbol,
#'                     background_list = background_list,
#'                     organism_name = "hsapiens",
#'                     pval_thr = 0.05,
#'                     correction = "fdr",
#'                     user_sources = c("GO:BP", "WP"),
#'                     respath = "test.txt")
#'
#' # Generate plots
#' gproGraph(gpro_res, "barplot.png", "dotplot.png", 12)
#'  ```
#'
#' Note:
#' -----
#' This function requires the gprofiler2 and ggplot2 packages to be installed.
#'
#' Credits:
#' --------
#' - Authors: Julie Ripoll and Céline Mandier
#' - Created: 2023-04-17
#' - License: CeCILL
#' - Version: 0.1.0

gproGraph <- function(gpro_res,
                      respath_plt1,
                      respath_plt2,
                      term_number) {
  if (!is.null(gpro_res)) {
    # Manhattan plot of cuntional enrichment results
    res_gpro <- gpro_res$result
    ## Ordered by p-value and keep top ten ids
    ordered_res <- res_gpro[order(res_gpro$p_value), ]
    if (!is.null(ordered_res)) {
      ## Keep top X terms
      term_list <- ordered_res$term_id[1:term_number]
      ## Plot terms
      p <- gostplot(gpro_res, capped = FALSE, interactive = FALSE)
      if (term_number <= 12) {
        dev.new(width = 7, height = 8, unit = "in")
        publish_gostplot(
          p,
          highlight_terms = as.vector(term_list)
        )
      } else {
        dev.new(width = 8, height = 10, unit = "in")
        publish_gostplot(
          p,
          highlight_terms = as.vector(term_list)
        )
      }
      ## Save plot
      ggsave(respath_plt1, last_plot(), limitsize = FALSE)
      # Dotplot
      ## Keep columns of interest for dotplot
      gp_mod <- ordered_res[, c(
        "query",
        "source",
        "term_id",
        "term_name",
        "p_value",
        "query_size",
        "intersection_size",
        "term_size",
        "effective_domain_size",
        "intersection"
      )]
      ## Add gene ratio
      gp_mod$GeneRatio <- as.numeric(gp_mod$intersection_size / gp_mod$query_size)
      ## Add background gene ratio
      gp_mod$BgRatio <- as.numeric(gp_mod$term_size / gp_mod$effective_domain_size)
      ## Rename
      names(gp_mod) <- c(
        "Cluster",
        "Category",
        "ID",
        "Description",
        "p.adjust",
        "query_size",
        "Count",
        "term_size",
        "effective_domain_size",
        "geneID",
        "GeneRatio",
        "BgRatio"
      )
      ## Extract gene ID
      gp_mod$geneID <- gsub(",", "/", gp_mod$geneID)
      row.names(gp_mod) <- gp_mod$ID
      gp_mod <- gp_mod[order(-gp_mod$term_size), ]
      # Drop na
      gp_mod_wt_na <- gp_mod[!is.na(gp_mod$term_size), ]
      ## Filter root term
      gp_mod_filt <- gp_mod_wt_na[!gp_mod_wt_na$Description %in% c(
        "WIKIPATHWAYS",
        "KEGG root term",
        "REACTOME root term",
        "biological_process",
        "cellular_component",
        "molecular_function",
        "CORUM root"
      ),]
      if (!nrow(gp_mod_filt) == 0) {
        ## Graph
        if (term_number <= 12) {
          dev.new(width = 7, height = 7, unit = "in")
          dotp <- dotplot_classic(
            gp_mod_filt,
            x = "term_size",
            color = "p.adjust",
            showCategory = term_number,
            size = "GeneRatio",
            font.size = 12,
            label_format = 35
          )
        } else if (term_number >= 30) {
          print("WARNING: term number should be < = at 30 terms for plotting, 
                value was fixed at 30 here")
          dev.new(width = 7.5, height = 12, unit = "in")
          dotp <- dotplot_classic(
            gp_mod_filt,
            x = "term_size",
            color = "p.adjust",
            showCategory = 30,
            size = "GeneRatio",
            font.size = 11,
            label_format = 50
          )
        } else {
          dev.new(width = 7, height = 9, unit = "in")
          dotp <- dotplot_classic(
            gp_mod_filt,
            x = "term_size",
            color = "p.adjust",
            showCategory = term_number,
            size = "GeneRatio",
            font.size = 11,
            label_format = 40
          )
        }
        dotp
        ## Save plot
        ggsave(respath_plt2, dotp, limitsize = FALSE)
      } else {
        print("WARNING: no enrichment, no plot")
      }
    } else {
      print("WARNING: no enrichment, no plot")
    }
  } else {
    print("WARNING: no enrichment, no plot")
  }
}
